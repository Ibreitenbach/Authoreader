<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Authoreader</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      margin: 0;
      color: #333;
    }

    h1 {
      color: white;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      margin-bottom: 2rem;
      font-size: 3rem;
    }

    #text-container {
      max-width: 800px;
      width: 90%;
      background: white;
      border-radius: 15px;
      padding: 2rem;
      margin-bottom: 2rem;
      font-size: 1.5rem;
      line-height: 2.5rem;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      max-height: 400px;
      overflow-y: auto;
    }

    .highlighted {
      color: #007bff;
      font-weight: bold;
      background-color: #eaf4ff;
      padding: 2px 4px;
      border-radius: 4px;
      transition: all 0.3s ease;
    }

    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
    }

    button {
      font-size: 1rem;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    #load-button {
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
    }

    #load-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
    }

    #mic-button {
      background: linear-gradient(45deg, #ff6b6b, #ee5a24);
      color: white;
    }

    #mic-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
    }

    #mic-button.listening {
      background: linear-gradient(45deg, #ff4757, #c44569);
      animation: pulse 1.5s infinite;
    }

    #skip-button {
      background: linear-gradient(45deg, #ffa726, #ff7043);
      color: white;
    }

    #skip-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 167, 38, 0.4);
    }

    #skip-button:disabled {
      background: #cccccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    #skip-cooldown {
      font-size: 0.8rem;
      color: #666;
      margin-top: 0.25rem;
    }
      background: linear-gradient(45deg, #3742fa, #2f3542);
      color: white;
    }

    #assist-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(55, 66, 250, 0.4);
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    #file-status {
      background: rgba(255, 255, 255, 0.9);
      padding: 1rem;
      border-radius: 10px;
      margin-bottom: 1rem;
      backdrop-filter: blur(10px);
      display: none;
    }

    #progress-container {
      width: 100%;
      max-width: 800px;
      background-color: rgba(255, 255, 255, 0.3);
      border-radius: 15px;
      margin: 1rem 0;
      padding: 4px;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }

    #progress-bar {
      width: 0%;
      height: 25px;
      background: linear-gradient(45deg, #4CAF50, #81C784, #66BB6A);
      border-radius: 12px;
      transition: width 0.5s ease;
      position: relative;
      overflow: hidden;
    }

    #progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      background: linear-gradient(
        90deg,
        transparent,
        rgba(255,255,255,0.4),
        transparent
      );
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    #progress-text {
      color: white;
      font-weight: bold;
      text-align: center;
      margin-top: 0.5rem;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      font-size: 1.1rem;
    }

    #listening-feedback {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 1rem;
      border-radius: 10px;
      max-width: 300px;
      display: none;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }

    #current-word-display {
      background: rgba(255, 255, 255, 0.1);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      margin: 1rem 0;
      text-align: center;
      color: white;
      font-size: 1.3rem;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      backdrop-filter: blur(10px);
    }

    .word-match {
      background-color: #4CAF50 !important;
      color: white !important;
      transform: scale(1.1);
      transition: all 0.3s ease;
    }

    .auto-skip {
      opacity: 0.3 !important;
      font-style: italic !important;
      color: #999 !important;
      text-decoration: line-through !important;
    }
      background-color: #ff9800 !important;
      color: white !important;
      opacity: 0.7;
    }
      background: #ffebee;
      color: #c62828;
      padding: 1rem;
      border-radius: 10px;
      margin: 1rem 0;
      border-left: 4px solid #c62828;
    }

    .success {
      background: #e8f5e8;
      color: #2e7d32;
      padding: 1rem;
      border-radius: 10px;
      margin: 1rem 0;
      border-left: 4px solid #2e7d32;
    }

    #voice-controls {
      background: rgba(255, 255, 255, 0.9);
      padding: 1rem;
      border-radius: 10px;
      margin-bottom: 1rem;
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    #voice-select {
      padding: 0.5rem 1rem;
      border: 2px solid #667eea;
      border-radius: 25px;
      background: white;
      font-size: 1rem;
      min-width: 200px;
      cursor: pointer;
    }

    #voice-select:focus {
      outline: none;
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
    }

    #test-voice-button {
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s ease;
    }

    #test-voice-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
    }

    #voice-settings {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .voice-control {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
    }

    .voice-control label {
      font-size: 0.8rem;
      color: #666;
      font-weight: 600;
    }

    .voice-control input[type="range"] {
      width: 80px;
      cursor: pointer;
    }
      color: white;
      margin-bottom: 1rem;
      font-size: 1.1rem;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <h1>üìö Authoreader</h1>

  <input type="file" id="file-input" accept=".txt,.pdf,.epub,.doc,.docx,.rtf,.odt,.html,.htm" style="display: none;">

  <div id="file-status">
    <div id="file-name"></div>
  </div>

  <div id="voice-controls">
    <div style="display: flex; align-items: center; gap: 1rem;">
      <label for="voice-select" style="font-weight: bold; color: #333;">üéôÔ∏è Voice:</label>
      <select id="voice-select">
        <option value="">Loading voices...</option>
      </select>
      <button id="test-voice-button">üîä Test Voice</button>
    </div>
    
    <div id="voice-settings">
      <div class="voice-control">
        <label for="voice-rate">Speed</label>
        <input type="range" id="voice-rate" min="0.5" max="2" step="0.1" value="0.8">
        <span id="rate-value">0.8x</span>
      </div>
      <div class="voice-control">
        <label for="voice-pitch">Pitch</label>
        <input type="range" id="voice-pitch" min="0.5" max="2" step="0.1" value="1.0">
        <span id="pitch-value">1.0x</span>
      </div>
      <div class="voice-control">
        <label for="voice-volume">Volume</label>
        <input type="range" id="voice-volume" min="0" max="1" step="0.1" value="0.8">
        <span id="volume-value">80%</span>
      </div>
    </div>
  </div>

  <div id="current-word-display">Ready to start reading...</div>

  <div id="listening-feedback">
    <div id="spoken-text"></div>
  </div>

  <div id="progress-container">
    <div id="progress-bar"></div>
  </div>
  <div id="progress-text">0% Complete</div>

  <div id="word-count"></div>

  <div id="text-container">
    <p id="text-display">Welcome to Authoreader! Click "Load Document" to upload a text file, PDF, EPUB, or Word document, then click "Start Listening" to begin reading practice.</p>
  </div>
  
  <div id="controls">
    <button id="load-button">üìÅ Load Document</button>
    <button id="mic-button">üé§ Start Listening</button>
    <button id="assist-button">üí° Get Help</button>
    <div style="text-align: center;">
      <button id="skip-button">‚è≠Ô∏è Skip Word</button>
      <div id="skip-cooldown"></div>
    </div>
  </div>

  <!-- External Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>

  <script>
    // Set up PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

    // Get references to HTML elements
    const textDisplay = document.getElementById('text-display');
    const micButton = document.getElementById('mic-button');
    const assistButton = document.getElementById('assist-button');
    const fileInput = document.getElementById('file-input');
    const loadButton = document.getElementById('load-button');
    const fileStatus = document.getElementById('file-status');
    const fileName = document.getElementById('file-name');
    const progressBar = document.getElementById('progress-bar');
    const progressText = document.getElementById('progress-text');
    const wordCount = document.getElementById('word-count');
    const listeningFeedback = document.getElementById('listening-feedback');
    const spokenTextDisplay = document.getElementById('spoken-text');
    const currentWordDisplay = document.getElementById('current-word-display');
    const skipButton = document.getElementById('skip-button');
    const skipCooldownDisplay = document.getElementById('skip-cooldown');
    const voiceSelect = document.getElementById('voice-select');
    const testVoiceButton = document.getElementById('test-voice-button');
    const voiceRateSlider = document.getElementById('voice-rate');
    const voicePitchSlider = document.getElementById('voice-pitch');
    const voiceVolumeSlider = document.getElementById('voice-volume');
    const rateValue = document.getElementById('rate-value');
    const pitchValue = document.getElementById('pitch-value');
    const volumeValue = document.getElementById('volume-value');

    // Application state
    let sourceText = '';
    let words = [];
    let currentIndex = 0;
    let isListening = false;
    let currentFile = null;
    let spokenBuffer = []; // Buffer to store recent spoken words
    let lastMatchTime = Date.now();
    let consecutiveMatches = 0;
    let feedbackTimeout = null;
    let lastSkipTime = 0; // Track when last skip was used
    let skipCooldown = 30000; // 30 seconds in milliseconds
    let selectedVoice = null; // Currently selected voice
    let voiceSettings = {
      rate: 0.8,
      pitch: 1.0,
      volume: 0.8
    };
    let wordsReadAloud = 0; // Track words actually spoken by user
    let totalReadableWords = 0; // Words that need to be read (excluding auto-skipped)

    // Speech Recognition & Synthesis setup
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    const synth = window.speechSynthesis;

    if (SpeechRecognition) {
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';
      recognition.maxAlternatives = 1; // Focus on the best result
    }

    // Initialize voice system
    loadVoices();

    // Initialize the application
    function initialize(text) {
      if (!text || text.trim().length === 0) {
        showError('No text content found in the document.');
        return;
      }

      currentIndex = 0;
      sourceText = text.trim();
      words = sourceText.split(/\s+/).filter(word => word.length > 0);
      
      // Update word count and reset progress
      wordCount.textContent = `üìä ${words.length} words loaded`;
      wordCount.style.display = 'block';
      
      // Reset progress bar
      progressBar.style.width = '0%';
      progressText.textContent = '0% Complete (0/' + words.length + ' words)';
      progressBar.style.background = 'linear-gradient(45deg, #4CAF50, #81C784, #66BB6A)';
      
      // Reset reading state
      spokenBuffer = [];
      lastMatchTime = Date.now();
      consecutiveMatches = 0;
      lastSkipTime = 0; // Reset skip cooldown
      wordsReadAloud = 0; // Reset spoken word count
      
      // Count readable words (excluding auto-skip characters)
      totalReadableWords = words.filter(word => !shouldAutoSkipWord(word)).length;
      
      currentWordDisplay.textContent = words.length > 0 ? `Current word: "${words[0]}"` : 'Ready to start reading...';
      
      // Update skip button state
      updateSkipButton();
      
      // Clear and rebuild text display
      textDisplay.innerHTML = '';
      words.forEach((word, index) => {
        const wordSpan = document.createElement('span');
        wordSpan.textContent = word + ' ';
        wordSpan.id = 'word-' + index;
        wordSpan.style.cursor = 'pointer';
        
        // Mark auto-skip words differently
        if (shouldAutoSkipWord(word)) {
          wordSpan.style.opacity = '0.5';
          wordSpan.style.fontStyle = 'italic';
          wordSpan.classList.add('auto-skip');
        }
        
        wordSpan.addEventListener('click', () => {
          currentIndex = index;
          highlightCurrentWord();
        });
        textDisplay.appendChild(wordSpan);
      });
      
      // Auto-skip to first readable word
      while (currentIndex < words.length && shouldAutoSkipWord(words[currentIndex])) {
        currentIndex++;
      }
      
      highlightCurrentWord();
      showSuccess(`Document loaded successfully! ${totalReadableWords} words to read (${words.length - totalReadableWords} auto-skipped).`);
    }

    // Clean word for comparison (remove punctuation and normalize)
    function cleanWord(word) {
      return word.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()"\[\]]/g, "").trim();
    }

    // Process spoken text and match with expected words
    function processSpokenText(transcript) {
      const spokenWords = transcript.split(/\s+/).filter(w => w.length > 0);
      const currentTime = Date.now();
      
      if (spokenWords.length === 0) return;
      
      // Get the current target word
      const targetWord = cleanWord(words[currentIndex] || '');
      if (!targetWord) return;
      
      let matched = false;
      
      // Check all recent spoken words, prioritizing the most recent
      for (let i = spokenWords.length - 1; i >= Math.max(0, spokenWords.length - 3); i--) {
        const spokenWord = cleanWord(spokenWords[i]);
        
        if (spokenWord.length < 1) continue; // Skip empty words
        
        // Multiple matching strategies for better recognition
        if (isWordMatch(spokenWord, targetWord)) {
          matched = true;
          console.log(`Matched: "${spokenWord}" -> "${targetWord}" ${areHomophones(spokenWord, targetWord) ? '(homophone)' : targetWord.length <= 2 ? '(short word)' : ''}`);
          break;
        }
      }
      
      if (matched) {
        // Mark word as successfully read
        const currentWordElement = document.getElementById('word-' + currentIndex);
        if (currentWordElement) {
          currentWordElement.classList.add('word-match');
          setTimeout(() => {
            currentWordElement.classList.remove('word-match');
          }, 800);
        }
        
        consecutiveMatches++;
        lastMatchTime = currentTime;
        
        // Count this as a word read aloud (for progress tracking)
        if (!shouldAutoSkipWord(words[currentIndex])) {
          wordsReadAloud++;
        }
        
        // Advance to next word
        currentIndex++;
        
        // Auto-skip unpronounceablewords
        while (currentIndex < words.length && shouldAutoSkipWord(words[currentIndex])) {
          const autoSkipElement = document.getElementById('word-' + currentIndex);
          if (autoSkipElement) {
            autoSkipElement.classList.add('auto-skip');
            autoSkipElement.style.textDecoration = 'line-through';
          }
          currentIndex++;
        }
        
        if (currentIndex < words.length) {
          highlightCurrentWord();
          currentWordDisplay.textContent = `Current word: "${words[currentIndex]}"`;
          
          // Update listening feedback to show success
          spokenTextDisplay.textContent = `‚úÖ Correct! Next word: "${words[currentIndex]}"`;
        } else {
          // Finished reading!
          finishReading();
        }
      } else {
        // Show what was heard vs what was expected
        const recentWord = spokenWords.length > 0 ? cleanWord(spokenWords[spokenWords.length - 1]) : '';
        if (recentWord.length > 1) {
          spokenTextDisplay.textContent = `üéß Heard: "${recentWord}" | Need: "${targetWord}"`;
        }
        
        // Check if user is stuck
        if (currentTime - lastMatchTime > 6000 && consecutiveMatches > 0) {
          offerHelp();
        }
      }
    }

    // Enhanced word matching function
    function isWordMatch(spoken, target) {
      if (!spoken || !target) return false;
      
      // Special handling for single letters and very short words
      if (target.length <= 2) {
        return isShortWordMatch(spoken, target);
      }
      
      // Exact match
      if (spoken === target) return true;
      
      // Check homophones (words that sound the same)
      if (areHomophones(spoken, target)) return true;
      
      // Handle common speech recognition issues
      const spokenNormalized = normalizeForSpeech(spoken);
      const targetNormalized = normalizeForSpeech(target);
      
      if (spokenNormalized === targetNormalized) return true;
      
      // Partial matches for longer words
      if (target.length > 4) {
        if (spoken.includes(target) || target.includes(spoken)) return true;
      }
      
      // Similarity match for words > 3 characters
      if (target.length > 3 && spoken.length > 3) {
        const distance = levenshteinDistance(spokenNormalized, targetNormalized);
        const maxDistance = Math.floor(Math.min(target.length, spoken.length) * 0.3);
        return distance <= maxDistance;
      }
      
      return false;
    }

    // Special matching for short words (1-2 characters)
    function isShortWordMatch(spoken, target) {
      const spokenLower = spoken.toLowerCase();
      const targetLower = target.toLowerCase();
      
      // Direct match
      if (spokenLower === targetLower) return true;
      
      // Special cases for common short words
      const shortWordMappings = {
        'a': ['a', 'uh', 'ah', 'ay', 'eh'],
        'i': ['i', 'eye', 'aye', 'ai'],
        'o': ['o', 'oh', 'owe'],
        'u': ['u', 'you', 'oo'],
        'it': ['it', 'at', 'et'],
        'is': ['is', 'as', 'his'],
        'in': ['in', 'an', 'on'],
        'of': ['of', 'off', 'ov'],
        'or': ['or', 'are', 'our'],
        'so': ['so', 'sew', 'sow'],
        'me': ['me', 'my', 'mee'],
        'he': ['he', 'hey', 'hee'],
        'we': ['we', 'wee', 'way'],
        'be': ['be', 'bee', 'b'],
        'go': ['go', 'glow', 'bow'], // Note: 'bow' can sound like 'go'
        'do': ['do', 'due', 'dew'],
        'no': ['no', 'know', 'now'],
        'up': ['up', 'uh', 'app'],
        'am': ['am', 'i\'m', 'um'],
        'an': ['an', 'and', 'in'],
        'as': ['as', 'is', 'has'],
        'at': ['at', 'it', 'hat'],
        'by': ['by', 'buy', 'bye'],
        'if': ['if', 'iv', 'of']
      };
      
      // Check if target word has special mappings
      if (shortWordMappings[targetLower]) {
        return shortWordMappings[targetLower].includes(spokenLower);
      }
      
      // For other short words, be more lenient with similar sounds
      if (targetLower.length <= 2 && spokenLower.length <= 3) {
        // Check if they start with the same letter
        if (targetLower[0] === spokenLower[0]) return true;
        
        // Check if they sound similar (common substitutions)
        const vowelPattern = /[aeiou]/g;
        const targetVowels = targetLower.match(vowelPattern) || [];
        const spokenVowels = spokenLower.match(vowelPattern) || [];
        
        if (targetVowels.length > 0 && spokenVowels.length > 0) {
          return targetVowels[0] === spokenVowels[0];
        }
      }
      
      return false;
    }

    // Check if two words are homophones (sound the same)
    function areHomophones(word1, word2) {
      // Convert both words to lowercase for comparison
      const w1 = word1.toLowerCase();
      const w2 = word2.toLowerCase();
      
      // Define homophone groups - words that sound the same
      const homophones = [
        ['2', 'to', 'too', 'two'],
        ['4', 'for', 'four', 'fore'],
        ['8', 'ate', 'eight'],
        ['1', 'one', 'won'],
        ['3', 'three', 'thee'],
        ['6', 'six', 'sicks'],
        ['there', 'their', 'theyre'],
        ['your', 'youre', 'yore'],
        ['its', 'it\'s'],
        ['hear', 'here'],
        ['sea', 'see', 'c'],
        ['be', 'bee', 'b'],
        ['are', 'r'],
        ['you', 'u'],
        ['why', 'y'],
        ['tea', 't'],
        ['pea', 'p'],
        ['queue', 'q', 'cue'],
        ['oh', 'o'],
        ['aye', 'i', 'eye'],
        ['right', 'write', 'rite'],
        ['know', 'no'],
        ['knew', 'new'],
        ['through', 'threw'],
        ['break', 'brake'],
        ['buy', 'by', 'bye'],
        ['cell', 'sell'],
        ['cent', 'sent', 'scent'],
        ['dear', 'deer'],
        ['fair', 'fare'],
        ['flour', 'flower'],
        ['heel', 'heal', 'he\'ll'],
        ['hole', 'whole'],
        ['hour', 'our'],
        ['mail', 'male'],
        ['meat', 'meet'],
        ['peace', 'piece'],
        ['plain', 'plane'],
        ['rain', 'reign', 'rein'],
        ['read', 'red'],
        ['road', 'rode'],
        ['sail', 'sale'],
        ['son', 'sun'],
        ['tail', 'tale'],
        ['wait', 'weight'],
        ['weak', 'week'],
        ['wear', 'where'],
        ['wood', 'would']
      ];
      
      // Check if both words are in the same homophone group
      for (const group of homophones) {
        if (group.includes(w1) && group.includes(w2)) {
          return true;
        }
      }
      
      return false;
    }

    // Normalize words for better speech recognition matching
    function normalizeForSpeech(word) {
      return word.toLowerCase()
        .replace(/['']/g, '') // Remove apostrophes
        .replace(/ph/g, 'f') // Common speech recognition substitutions
        .replace(/ck/g, 'k')
        .replace(/qu/g, 'kw')
        .replace(/x/g, 'ks');
    }

    // Calculate edit distance between two words
    function levenshteinDistance(str1, str2) {
      const matrix = [];
      
      for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
      }
      
      for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
      }
      
      for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
          if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1,
              matrix[i][j - 1] + 1,
              matrix[i - 1][j] + 1
            );
          }
        }
      }
      
      return matrix[str2.length][str1.length];
    }

    // Show real-time listening feedback
    function updateListeningFeedback(transcript) {
      if (feedbackTimeout) {
        clearTimeout(feedbackTimeout);
      }
      
      if (!transcript) {
        listeningFeedback.style.display = 'none';
        return;
      }
      
      const targetWord = words[currentIndex] || '';
      spokenTextDisplay.innerHTML = `
        <div style="margin-bottom: 0.5rem;">
          <strong>Target:</strong> "${targetWord}"
        </div>
        <div>
          <strong>You said:</strong> "${transcript}"
        </div>
      `;
      listeningFeedback.style.display = 'block';
      
      feedbackTimeout = setTimeout(() => {
        listeningFeedback.style.display = 'none';
      }, 4000);
    }

    // Offer help when user is stuck
    function offerHelp() {
      const targetWord = words[currentIndex];
      currentWordDisplay.textContent = `Having trouble with: "${targetWord}" - Try saying it clearly or click Get Help!`;
      currentWordDisplay.style.background = 'rgba(255, 152, 0, 0.3)';
      
      setTimeout(() => {
        currentWordDisplay.style.background = 'rgba(255, 255, 255, 0.1)';
        if (currentIndex < words.length) {
          currentWordDisplay.textContent = `Current word: "${words[currentIndex]}"`;
        }
      }, 3000);
      
      // Just pronounce the word briefly (full help available via Get Help button)
      speakWord(targetWord);
    }

    // Handle successful completion
    function finishReading() {
      micButton.textContent = 'üéâ Finished!';
      micButton.classList.remove('listening');
      recognition.stop();
      currentWordDisplay.textContent = 'üéâ Congratulations! You finished reading!';
      currentWordDisplay.style.background = 'rgba(76, 175, 80, 0.3)';
      showSuccess('Congratulations! You\'ve successfully read the entire document!');
      
      // Celebration effect
      setTimeout(() => {
        currentWordDisplay.style.background = 'rgba(255, 255, 255, 0.1)';
      }, 5000);
    }

    // Skip word functionality with cooldown
    function skipCurrentWord() {
      const currentTime = Date.now();
      const timeSinceLastSkip = currentTime - lastSkipTime;
      
      if (timeSinceLastSkip < skipCooldown) {
        const remainingTime = Math.ceil((skipCooldown - timeSinceLastSkip) / 1000);
        showError(`Skip is on cooldown. Wait ${remainingTime} more seconds.`);
        return;
      }
      
      if (currentIndex >= words.length) {
        showError('No more words to skip!');
        return;
      }
      
      // Mark the current word as skipped
      const currentWordElement = document.getElementById('word-' + currentIndex);
      if (currentWordElement) {
        currentWordElement.classList.add('word-skip');
      }
      
      // Record the skip
      lastSkipTime = currentTime;
      
      // Advance to next word
      currentIndex++;
      if (currentIndex < words.length) {
        highlightCurrentWord();
        currentWordDisplay.textContent = `Current word: "${words[currentIndex]}"`;
        showSuccess(`Word skipped! Next word: "${words[currentIndex]}"`);
      } else {
        finishReading();
      }
      
      // Update skip button state
      updateSkipButton();
      
      // Start cooldown timer
      startSkipCooldownTimer();
    }

    // Update skip button state and cooldown display
    function updateSkipButton() {
      const currentTime = Date.now();
      const timeSinceLastSkip = currentTime - lastSkipTime;
      const isOnCooldown = timeSinceLastSkip < skipCooldown;
      
      skipButton.disabled = isOnCooldown || currentIndex >= words.length;
      
      if (currentIndex >= words.length) {
        skipButton.textContent = '‚è≠Ô∏è No More Words';
        skipCooldownDisplay.textContent = '';
      } else if (isOnCooldown) {
        const remainingTime = Math.ceil((skipCooldown - timeSinceLastSkip) / 1000);
        skipButton.textContent = `‚è≠Ô∏è Skip (${remainingTime}s)`;
        skipCooldownDisplay.textContent = `Cooldown: ${remainingTime} seconds`;
      } else {
        skipButton.textContent = '‚è≠Ô∏è Skip Word';
        skipCooldownDisplay.textContent = 'Available (once per 30s)';
      }
    }

    // Start the skip cooldown timer
    function startSkipCooldownTimer() {
      const timer = setInterval(() => {
        updateSkipButton();
        
        const currentTime = Date.now();
        const timeSinceLastSkip = currentTime - lastSkipTime;
        
        if (timeSinceLastSkip >= skipCooldown) {
          clearInterval(timer);
          updateSkipButton();
        }
      }, 1000);
    }

    // Check if a word should be automatically skipped
    function shouldAutoSkipWord(word) {
      if (!word) return true;
      
      const cleanedWord = word.trim();
      
      // Auto-skip characters/symbols with no pronunciation
      const autoSkipPatterns = [
        '|',           // Pipe character
        '||',          // Double pipe
        '/',           // Forward slash alone
        '\\',          // Backslash alone
        '*',           // Asterisk alone
        '**',          // Double asterisk
        '***',         // Triple asterisk
        '#',           // Hash alone
        '##',          // Double hash
        '###',         // Triple hash
        '---',         // Triple dash
        '===',         // Triple equals
        '...',         // Ellipsis (though this could be pronounceable)
        '',            // Empty string
        '-',           // Single dash
        '_',           // Underscore
        '=',           // Equals sign
        '+',           // Plus sign
        '~',           // Tilde
        '^',           // Caret
        '&',           // Ampersand alone (though "and" is pronounceable)
        '%',           // Percent alone
        '@',           // At symbol alone
        '!',           // Exclamation alone
        '?',           // Question mark alone
        ';',           // Semicolon alone
        ':',           // Colon alone
        ',',           // Comma alone
        '.',           // Period alone
      ];
      
      // Check if word exactly matches auto-skip patterns
      if (autoSkipPatterns.includes(cleanedWord)) {
        return true;
      }
      
      // Auto-skip if word is only punctuation/symbols (no letters or numbers)
      if (!/[a-zA-Z0-9]/.test(cleanedWord)) {
        return true;
      }
      
      return false;
    }
    function highlightCurrentWord() {
      const prevWordElement = document.querySelector('.highlighted');
      if (prevWordElement) {
        prevWordElement.classList.remove('highlighted');
      }
      const currentWordElement = document.getElementById('word-' + currentIndex);
      if (currentWordElement) {
        currentWordElement.classList.add('highlighted');
        currentWordElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
      
      // Update progress
      const progress = words.length > 0 ? ((currentIndex / words.length) * 100) : 0;
      const progressPercent = Math.min(100, Math.max(0, progress)).toFixed(1);
      progressBar.style.width = progressPercent + '%';
      progressText.textContent = `${progressPercent}% Complete (${currentIndex}/${words.length} words)`;
      
      // Change progress bar color as it nears completion
      if (progress >= 100) {
        progressBar.style.background = 'linear-gradient(45deg, #FFD700, #FFA500, #FF8C00)';
        progressText.textContent = 'üéâ 100% Complete - Well done!';
      } else if (progress >= 75) {
        progressBar.style.background = 'linear-gradient(45deg, #FF6B6B, #FF8E53, #FF6B9D)';
      } else if (progress >= 50) {
        progressBar.style.background = 'linear-gradient(45deg, #4ECDC4, #44A08D, #093637)';
      } else {
        progressBar.style.background = 'linear-gradient(45deg, #4CAF50, #81C784, #66BB6A)';
      }
    }

    // File reading functions
    async function readTextFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = () => reject(new Error('Failed to read text file'));
        reader.readAsText(file);
      });
    }

    async function readPdfFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const arrayBuffer = e.target.result;
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            let fullText = '';
            
            for (let i = 1; i <= pdf.numPages; i++) {
              const page = await pdf.getPage(i);
              const textContent = await page.getTextContent();
              const pageText = textContent.items.map(item => item.str).join(' ');
              fullText += pageText + ' ';
            }
            
            resolve(fullText);
          } catch (error) {
            reject(new Error('Failed to parse PDF: ' + error.message));
          }
        };
        reader.onerror = () => reject(new Error('Failed to read PDF file'));
        reader.readAsArrayBuffer(file);
      });
    }

    async function readEpubFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const arrayBuffer = e.target.result;
            const zip = await JSZip.loadAsync(arrayBuffer);
            let fullText = '';
            
            // Find all HTML/XHTML files in the EPUB
            const htmlFiles = [];
            zip.forEach((relativePath, zipEntry) => {
              if (relativePath.match(/\.(x?html?)$/i) && !zipEntry.dir) {
                htmlFiles.push(relativePath);
              }
            });
            
            // Read content from HTML files
            for (const htmlFile of htmlFiles) {
              const content = await zip.file(htmlFile).async('string');
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = content;
              // Remove script and style elements
              const scripts = tempDiv.querySelectorAll('script, style');
              scripts.forEach(el => el.remove());
              fullText += tempDiv.textContent || tempDiv.innerText || '';
              fullText += ' ';
            }
            
            resolve(fullText);
          } catch (error) {
            reject(new Error('Failed to parse EPUB: ' + error.message));
          }
        };
        reader.onerror = () => reject(new Error('Failed to read EPUB file'));
        reader.readAsArrayBuffer(file);
      });
    }

    async function readWordFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const arrayBuffer = e.target.result;
            const result = await mammoth.extractRawText({ arrayBuffer });
            resolve(result.value);
          } catch (error) {
            reject(new Error('Failed to parse Word document: ' + error.message));
          }
        };
        reader.onerror = () => reject(new Error('Failed to read Word file'));
        reader.readAsArrayBuffer(file);
      });
    }

    async function readHtmlFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const content = e.target.result;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            // Remove script and style elements
            const scripts = tempDiv.querySelectorAll('script, style');
            scripts.forEach(el => el.remove());
            const text = tempDiv.textContent || tempDiv.innerText || '';
            resolve(text);
          } catch (error) {
            reject(new Error('Failed to parse HTML: ' + error.message));
          }
        };
        reader.onerror = () => reject(new Error('Failed to read HTML file'));
        reader.readAsText(file);
      });
    }

    // Process uploaded file
    async function processFile(file) {
      currentFile = file;
      fileName.textContent = `üìÑ Loading: ${file.name}`;
      fileStatus.style.display = 'block';
      progressBar.style.width = '0%';

      try {
        let text = '';
        const fileType = file.type.toLowerCase();
        const fileExtension = file.name.split('.').pop().toLowerCase();

        if (fileType === 'application/pdf' || fileExtension === 'pdf') {
          text = await readPdfFile(file);
        } else if (fileType === 'application/epub+zip' || fileExtension === 'epub') {
          text = await readEpubFile(file);
        } else if (fileType.includes('word') || fileExtension === 'doc' || fileExtension === 'docx') {
          text = await readWordFile(file);
        } else if (fileType === 'text/html' || fileExtension === 'html' || fileExtension === 'htm') {
          text = await readHtmlFile(file);
        } else {
          // Default to text file
          text = await readTextFile(file);
        }

        initialize(text);
        fileName.textContent = `‚úÖ Loaded: ${file.name}`;
      } catch (error) {
        showError(`Error loading file: ${error.message}`);
        fileName.textContent = `‚ùå Failed to load: ${file.name}`;
      }
    }

    // Utility functions
    function showError(message) {
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error';
      errorDiv.textContent = message;
      document.body.insertBefore(errorDiv, document.getElementById('controls'));
      setTimeout(() => errorDiv.remove(), 5000);
    }

    function showSuccess(message) {
      const successDiv = document.createElement('div');
      successDiv.className = 'success';
      successDiv.textContent = message;
      document.body.insertBefore(successDiv, document.getElementById('controls'));
      setTimeout(() => successDiv.remove(), 3000);
    }

    // Event listeners
    loadButton.addEventListener('click', () => {
      fileInput.click();
    });

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        processFile(file);
      }
    });

    // Skip button event listener
    skipButton.addEventListener('click', () => {
      if (words.length === 0) {
        showError('Please load a document first!');
        return;
      }
      skipCurrentWord();
    });

    // Voice control event listeners
    voiceSelect.addEventListener('change', handleVoiceChange);
    testVoiceButton.addEventListener('click', testVoice);

    // Voice setting sliders
    voiceRateSlider.addEventListener('input', (e) => {
      voiceSettings.rate = parseFloat(e.target.value);
      updateVoiceDisplays();
    });

    voicePitchSlider.addEventListener('input', (e) => {
      voiceSettings.pitch = parseFloat(e.target.value);
      updateVoiceDisplays();
    });

    voiceVolumeSlider.addEventListener('input', (e) => {
      voiceSettings.volume = parseFloat(e.target.value);
      updateVoiceDisplays();
    });

    // Handle voice loading (some browsers load voices asynchronously)
    if ('onvoiceschanged' in synth) {
      synth.onvoiceschanged = loadVoices;
    }

    if (recognition) {
      micButton.addEventListener('click', () => {
        if (words.length === 0) {
          showError('Please load a document first!');
          return;
        }

        if (isListening) {
          recognition.stop();
        } else {
          recognition.start();
        }
      });

      // Speech recognition event handlers
      recognition.onresult = (event) => {
        let finalTranscript = '';
        let interimTranscript = '';
        
        // Process all results for real-time matching
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript;
          } else {
            interimTranscript += transcript;
          }
        }
        
        // Use both final and interim for immediate response
        const allTranscript = (finalTranscript + ' ' + interimTranscript).toLowerCase().trim();
        
        if (allTranscript) {
          processSpokenText(allTranscript);
        }
        
        // Show real-time feedback
        updateListeningFeedback(allTranscript);
      };

      recognition.onstart = () => {
        isListening = true;
        micButton.textContent = '‚èπÔ∏è Stop Listening';
        micButton.classList.add('listening');
        listeningFeedback.style.display = 'block';
        spokenTextDisplay.textContent = 'Listening... start reading!';
        
        // Reset tracking variables
        spokenBuffer = [];
        lastMatchTime = Date.now();
      };

      recognition.onend = () => {
        isListening = false;
        micButton.classList.remove('listening');
        listeningFeedback.style.display = 'none';
        if (currentIndex < words.length) {
          micButton.textContent = 'üé§ Start Listening';
        }
      };

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        showError('Speech recognition error: ' + event.error);
      };
    } else {
      micButton.addEventListener('click', () => {
        showError('Speech recognition is not supported in this browser. Please use Chrome, Edge, or Safari.');
      });
    }

    assistButton.addEventListener('click', async () => {
      if (words.length === 0) {
        showError('Please load a document first!');
        return;
      }

      const targetWord = words[currentIndex];
      
      // Check if current word should be auto-skipped
      if (shouldAutoSkipWord(targetWord)) {
        showError('This character has no pronunciation and will be automatically skipped.');
        // Auto advance to next readable word
        while (currentIndex < words.length && shouldAutoSkipWord(words[currentIndex])) {
          currentIndex++;
        }
        if (currentIndex < words.length) {
          highlightCurrentWord();
          currentWordDisplay.textContent = `Current word: "${words[currentIndex]}"`;
        }
        return;
      }
      
      // Pause speech recognition during help
      const wasListening = isListening;
      if (isListening) {
        recognition.stop();
      }
      
      // Show that we're getting help
      assistButton.textContent = 'üîÑ Getting Help...';
      assistButton.disabled = true;

      try {
        const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${targetWord}`);
        if (!response.ok) throw new Error('Word not found');
        
        const data = await response.json();
        const definition = data[0].meanings[0].definitions[0].definition;
        const partOfSpeech = data[0].meanings[0].partOfSpeech;
        
        // Get pronunciation if available
        let pronunciation = '';
        if (data[0].phonetics && data[0].phonetics.length > 0) {
          const phoneticWithText = data[0].phonetics.find(p => p.text);
          if (phoneticWithText) {
            pronunciation = phoneticWithText.text;
          }
        }
        
        // Create simple, clear spoken text
        let spokenText = `The word is ${targetWord}.`;
        
        if (partOfSpeech) {
          spokenText += ` It is a ${partOfSpeech}.`;
        }
        
        spokenText += ` Definition: ${definition}`;
        
        // Show visual feedback
        currentWordDisplay.textContent = `üîä Help: "${targetWord}"`;
        currentWordDisplay.style.background = 'rgba(55, 66, 250, 0.3)';
        
        // Speak the definition
        await speakTextAloud(spokenText);
        
        // Reset visual feedback
        currentWordDisplay.style.background = 'rgba(255, 255, 255, 0.1)';
        currentWordDisplay.textContent = `Current word: "${targetWord}"`;
        
      } catch (error) {
        // Simple fallback - just pronounce the word
        const errorText = `The word is ${targetWord}.`;
        await speakTextAloud(errorText);
        console.error('Dictionary API error:', error);
      } finally {
        // Reset button
        assistButton.textContent = 'üí° Get Help';
        assistButton.disabled = false;
        
        // Resume speech recognition if it was active before
        if (wasListening && recognition && currentIndex < words.length) {
          setTimeout(() => {
            try {
              recognition.start();
            } catch (error) {
              console.log('Could not restart recognition:', error);
            }
          }, 1000);
        }
      }
    });

    // Helper function to speak a word
    function speakWord(word) {
      if (synth.speaking) {
        synth.cancel();
      }
      const utterance = new SpeechSynthesisUtterance(word);
      applyVoiceSettings(utterance);
      utterance.onerror = (event) => console.error('Speech synthesis error:', event.error);
      synth.speak(utterance);
    }

    // Enhanced function to speak longer text with proper pacing
    function speakTextAloud(text) {
      return new Promise((resolve, reject) => {
        // Cancel any ongoing speech first
        if (synth.speaking) {
          synth.cancel();
          // Wait a moment for cancellation to complete
          setTimeout(() => {
            startSpeaking();
          }, 100);
        } else {
          startSpeaking();
        }
        
        function startSpeaking() {
          const utterance = new SpeechSynthesisUtterance(text);
          applyVoiceSettings(utterance);
          
          // Handle completion and errors
          utterance.onend = () => {
            console.log('Speech completed successfully');
            resolve();
          };
          
          utterance.onerror = (event) => {
            console.error('Speech synthesis error:', event.error);
            resolve(); // Resolve anyway to not block the UI
          };
          
          // Ensure speech synthesis is ready
          if (synth.paused) {
            synth.resume();
          }
          
          try {
            synth.speak(utterance);
            
            // Fallback timeout in case speech gets stuck
            setTimeout(() => {
              if (synth.speaking) {
                console.log('Speech timeout - completing');
                synth.cancel();
                resolve();
              }
            }, text.length * 100 + 5000); // Dynamic timeout based on text length
            
          } catch (error) {
            console.error('Error starting speech:', error);
            resolve();
          }
        }
      });
    }

    // Apply voice settings to utterance
    function applyVoiceSettings(utterance) {
      if (selectedVoice) {
        utterance.voice = selectedVoice;
      }
      utterance.rate = voiceSettings.rate;
      utterance.pitch = voiceSettings.pitch;
      utterance.volume = voiceSettings.volume;
    }

    // Load available voices
    function loadVoices() {
      const voices = synth.getVoices();
      
      if (voices.length === 0) {
        // Voices might not be loaded yet, try again
        setTimeout(loadVoices, 100);
        return;
      }
      
      // Clear existing options
      voiceSelect.innerHTML = '';
      
      // Add default option
      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = 'System Default';
      voiceSelect.appendChild(defaultOption);
      
      // Group voices by language
      const englishVoices = voices.filter(voice => voice.lang.startsWith('en'));
      const otherVoices = voices.filter(voice => !voice.lang.startsWith('en'));
      
      // Add English voices first
      if (englishVoices.length > 0) {
        const englishGroup = document.createElement('optgroup');
        englishGroup.label = 'English Voices';
        englishVoices.forEach((voice, index) => {
          const option = document.createElement('option');
          option.value = index;
          option.textContent = `${voice.name} (${voice.lang})`;
          if (voice.default) {
            option.textContent += ' - Default';
          }
          englishGroup.appendChild(option);
        });
        voiceSelect.appendChild(englishGroup);
      }
      
      // Add other language voices
      if (otherVoices.length > 0) {
        const otherGroup = document.createElement('optgroup');
        otherGroup.label = 'Other Languages';
        otherVoices.forEach((voice, index) => {
          const option = document.createElement('option');
          option.value = englishVoices.length + index;
          option.textContent = `${voice.name} (${voice.lang})`;
          otherGroup.appendChild(option);
        });
        voiceSelect.appendChild(otherGroup);
      }
      
      // Set default voice (prefer English voices)
      if (englishVoices.length > 0) {
        const defaultVoice = englishVoices.find(voice => voice.default) || englishVoices[0];
        const defaultIndex = voices.indexOf(defaultVoice);
        voiceSelect.value = defaultIndex;
        selectedVoice = defaultVoice;
      }
    }

    // Handle voice selection change
    function handleVoiceChange() {
      const voices = synth.getVoices();
      const selectedIndex = parseInt(voiceSelect.value);
      
      if (isNaN(selectedIndex) || selectedIndex < 0) {
        selectedVoice = null;
      } else {
        selectedVoice = voices[selectedIndex];
      }
      
      console.log('Voice changed to:', selectedVoice ? selectedVoice.name : 'System Default');
    }

    // Test the selected voice
    function testVoice() {
      const testText = "Hello! This is how I sound. I will help you learn to read.";
      speakTextAloud(testText);
    }

    // Update voice setting displays
    function updateVoiceDisplays() {
      rateValue.textContent = voiceSettings.rate + 'x';
      pitchValue.textContent = voiceSettings.pitch + 'x';
      volumeValue.textContent = Math.round(voiceSettings.volume * 100) + '%';
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (event) => {
      if (event.code === 'Space' && words.length > 0) {
        event.preventDefault();
        if (recognition && !isListening) {
          recognition.start();
        }
      } else if (event.code === 'ArrowRight' && words.length > 0) {
        event.preventDefault();
        if (currentIndex < words.length - 1) {
          currentIndex++;
          highlightCurrentWord();
        }
      } else if (event.code === 'ArrowLeft' && words.length > 0) {
        event.preventDefault();
        if (currentIndex > 0) {
          currentIndex--;
          highlightCurrentWord();
        }
      } else if (event.code === 'KeyS' && event.ctrlKey && words.length > 0) {
        event.preventDefault();
        skipCurrentWord();
      }
    });

    // Initialize skip button state
    updateSkipButton();
    
    // Initialize voice displays
    updateVoiceDisplays();
  </script>
</body>
</html>